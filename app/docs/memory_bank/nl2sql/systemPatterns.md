# NL2SQL系统模式与架构

## 整体架构

NL2SQL模块采用了多层架构设计，通过清晰的职责分离实现系统的可维护性与可扩展性。下图展示了NL2SQL模块的主要组件及数据流：

```
┌─────────────┐     ┌───────────────┐     ┌─────────────────┐
│ Web界面/API │────>│ 查询预处理器  │────>│ SQL转换服务     │
└─────────────┘     └───────────────┘     └─────────────────┘
       │                                           │
       │                                           ▼
       │                                  ┌─────────────────┐
       │                                  │ 实体增强器      │
       │                                  └─────────────────┘
       │                                           │
       ▼                                           ▼
┌─────────────┐                          ┌─────────────────┐
│ 响应格式化  │<─────────────────────────│ 数据库查询执行  │
└─────────────┘                          └─────────────────┘
```

## 核心组件

### 1. 查询预处理器 (Query Preprocessor)

**职责**：
- 解析时间表达式
- 识别关键实体（用户名、IP地址等）
- 初步分析查询意图

**实现模式**：
- 使用正则表达式进行模式匹配
- 采用责任链模式处理不同类型的查询预处理
- 返回处理后的查询文本和提取的元数据（如时间范围）

**关键方法**：
- `_preprocess_query()`: 主入口，协调各种预处理步骤
- `_update_time_range()`: 处理相对时间表达式
- `_handle_special_time_range()`: 处理特殊时间表达式（今天、昨天等）
- `_parse_absolute_time_range()`: 解析绝对时间范围
- `_map_status_keyword()`: 映射状态关键词

### 2. SQL转换服务 (SQL Conversion Service)

**职责**：
- 构建LLM查询提示
- 调用OpenRouter API
- 从API响应中提取SQL
- 提供模式匹配回退机制

**实现模式**：
- 采用策略模式，支持不同的SQL生成策略
- 使用工厂模式创建适当的转换器
- 失败时优雅降级到回退策略

**关键方法**：
- `convert()`: 主入口，协调整个转换流程
- `_build_prompt()`: 构建发送给LLM的提示
- `_call_openrouter_api()`: 调用API
- `_extract_sql()`: 从API响应中提取SQL语句
- `_pattern_matching_fallback()`: 模式匹配回退方法

### 3. 实体增强器 (Entity Enhancer)

**职责**：
- 扩展实体匹配模式
- 处理多表查询
- 优化查询性能

**实现模式**：
- 使用装饰器模式增强SQL查询
- 采用访问者模式处理不同类型的SQL语句

**关键方法**：
- `_enhance_entity_matching()`: 增强实体匹配的主入口
- `_enhance_single_query()`: 增强单个查询
- `_generate_multiple_matches()`: 为实体生成多种匹配条件

### 4. 数据库查询执行器 (DB Query Executor)

**职责**：
- 执行SQL查询
- 处理查询错误
- 返回查询结果

**实现方式**：
- 使用数据库连接池管理连接
- 实现事务管理
- 错误处理与重试机制

### 5. Web界面与API (Web Interface & API)

**职责**：
- 提供用户界面
- 处理API请求
- 格式化查询结果

**实现模式**：
- 遵循RESTful API设计
- 使用Flask蓝图组织路由
- 采用MVC模式分离关注点

## 关键技术决策

### 1. 使用OpenRouter而非直接API调用

**决策**：使用OpenRouter作为LLM的API代理。

**原因**：
- 提供多模型访问能力，可以自动选择最佳模型
- 简化API密钥管理
- 提供统一的API接口

**权衡**：
- 优点：简化集成，提高灵活性
- 缺点：增加一层依赖，可能引入额外延迟

### 2. 双层转换策略（LLM + 模式匹配）

**决策**：实现LLM转换和模式匹配两种转换策略。

**原因**：
- 确保无API环境下的功能可用性
- 提高系统容错能力

**权衡**：
- 优点：增强系统稳定性，降低外部依赖
- 缺点：维护两套转换逻辑，增加开发复杂度

### 3. 查询预处理与后处理分离

**决策**：将查询预处理和查询后处理（实体增强）分为独立步骤。

**原因**：
- 分离关注点，使各组件职责更清晰
- 允许独立优化各处理步骤
- 便于测试和维护

**权衡**：
- 优点：更清晰的代码结构，更好的可测试性
- 缺点：可能引入额外的处理开销

## 数据流

1. 用户通过Web界面或API提交自然语言查询
2. 查询预处理器解析查询，提取时间范围和关键实体
3. SQL转换服务生成初步SQL查询
4. 实体增强器优化SQL查询
5. 数据库查询执行器运行SQL并返回结果
6. 结果被格式化并返回给用户

## 扩展点

系统设计了以下扩展点：

1. **转换策略**：可添加新的SQL生成策略（如基于微调模型的转换）
2. **查询模板**：可添加特定领域的查询模板（如安全事件调查模板）
3. **结果处理器**：可添加新的结果处理器（如可视化处理器）
4. **实体识别器**：可添加新的实体识别器（如威胁情报实体） 